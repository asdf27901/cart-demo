# 前端学习常见问题

## 一、JS篇

### 1.节流

### 2.防抖

### 3.this指向

### 4.改变this指向

### 5.对象实例构造方法

### 6.prototype详解

### 7.闭包

### 8.函数参数

## 二、Vue篇

### 1.vue中常用的指令
  - v-if/v-else
  - v-for
  - v-bind
  - v-model
  - v-slot
  - @

### 2.computed计算属性（简写/完整写法）

- 以下是计算属性的简写写法，无法直接修改计算属性的值

````html
<div id="app">
    姓：<input type="text" v-model="firstName"> +
    名：<input type="text" v-model="lastName"> =
    <span> {{ fullName }} </span>
    
    <button>改名卡</button>
</div>
<script>
	const app = new Vue({
        el: '#app',
        data: {
            firstName: '张',
            lastName: '飞'
        },
        computed: {
            fullName() {
                return this.firstName + this.lastName
            }
        }
    })
</script>
````

- 以下是计算属性的完整写法，可以修改计算属性的值，间接的影响组成计算属性的值

```` html
<div id="app">
    姓：<input type="text" v-model="firstName"> +
    名：<input type="text" v-model="lastName"> =
    <span> {{ fullName }} </span>
    
    <button @click="changeName">改名卡</button>
</div>
<script>
	const app = new Vue({
        el: '#app',
        data: {
            firstName: '张',
            lastName: '飞'
        },
        methods: {
            changeName() {
                this.fullName = '姬小满'
            }
        },
        computed: {
            fullName: {
                get() {
                    return this.firstName + this.lastName
                },
                set(value) {
                    this.firstName = value.slice(0,1)
                    this.lastName = value.slice(1)
                }
            }
        }
    })
</script>
````

### 3.watch监听器（简写/完整写法）

- 以下是监听器的简写写法

````html
<div id="app">
    <textarea v-model="words"></textarea>
    <textarea v-model="obj.words"></textarea>
</div>

<script>
	const app = new Vue({
        el: '#app',
        data: {
            words: '',
            obj: {
            	words: ""
        	}
        },
        watch: {
            words(newValue, oldValue) {
                console.log(`变更前: ${oldValue}, 变更后: ${newValue}`)
            },
            // 对象的写法
            'obj.words'(newValue, oldValue) {
                console.log(`变更前: ${oldValue}, 变更后: ${newValue}`)
            }
        }

    })
</script>
````

- 以下是监听器的完整写法

````html
<div id="app">
    <textarea v-model="obj.lang"></textarea>
    <textarea v-model="obj.words"></textarea>
</div>

<script>
	const app = new Vue({
        el: '#app',
        data: {
            words: '',
            obj: {
            	words: ""
                lang:
        	}
        },
        watch: {
           obj: {
               deep: true,   // obj对象下的所有内容都进入监听状态
               immediate: true,  // 是否立即执行一次handler中的函数
               handler(newValue){
                   console.log(`我是新的值${newValue}`)
               }
           }
        }

    })
</script>
````

### 4.Vue生命周期

① 创建阶段（before Create / created）：一般用户获取响应式数据

② 挂载阶段（before Mount / mounted）：渲染模版模版，到达mounted阶段时，完成dom结构渲染

③ 更新阶段（before Update / updated）：修改数据，更新视图

④ 销毁阶段（before Destroy / destroyed）：销毁实例

### 5.脚手架（Vue-CLi）
- 使用步骤
  
  1. 全局安装：yarn global add @vue-cli 或 npm i @vue/cli -g
  2. 查看Vue版本：vue --version
  3. 创建项目架子：vue create project-name （项目名不能用中文）
  4. 启动项目：yarn serve 或 npm run serve （从package.json得出）


- 创建架子目录结构
    ![架子目录结构](assets%2Fimg.png)

### 6.组件化开发&根组件
![组件化开发&根组件](assets%2Fimg_2.png)
![App.Vue根组件](assets%2Fimg_1.png)


### 7.普通组件的注册使用
- 局部注册：只能在注册的组件内使用
  1. 创建.Vue文件
  2. 通过import引入创建好的组件
  ![注册普通组件](assets%2Fimg_3.png)
  **如果组件名和组件对象名称都是一样可以直接用简写**
  ```vue
  <script>
  import HmHeader from './components/HmHeader'
  
  export default {
    components: {
        HmHeader
    }
  } 
  </script>
  ```
  
- 全局注册：所有组件内都能使用
  1. 创建.Vue文件
  2. main.js中进行全局注册
     ![注册全局组件](assets%2Fimg_4.png)
     **全局注册后，该组件不需要导入可以直接使用**


### 8.组件的样式冲突
默认情况：写在组件中的样式会**全局生效** -> 因此很容易造成多个组件之间的样式冲突问题
1. **<font color=red>全局样式</font>**：默认组件中的样式会作用到全局
2. **<font color=red>局部样式</font>**：可以给组件上<font color=red>scoped</font>属性，让样式只作用于当前组件中


### 9.组件通信
1. 父子关系：通过<font color=red>**props**</font>和<font color=red>**$emit**</font>进行父子组件通信
    - 父组件向子组件通信：父组件通过子组件的props中定义的变量参数，在父组件中使用子组件时，通过v-bind将数据传递给子组件，子组件通过props中定义的变量参数进行接收

    ```vue
    <!--App.vue-->
    <template>
    	<div>
            我是App组件
            <Son :title="myTitle"></Son>
        </div>
    </template>
    
    <script>
    	import Son from './components/Son.vue'
        export default {
            data() {
                return {
                    myTitle: "我的标题"
                }
            }，
            components: {
            	Son
        	}
        }
        
    </script>
    
    <style>
    </style>
    ```

    ```vue
    <!--Son.vue-->
    <template>
    	<div>
            我是son组件 {{ tilte }}
            
        </div>
    </template>
    
    <script>
        export default {
            // 通过props进行接收，title为定义的形参
            props: ["title"]
        }
    </script>
    
    <style>
    </style>
    
    ```

    - 子组件向父组件通信：子组件通过$emit向父组件发送触发的事件，父组件通过对应的事件调用方法，从而达到子组件向父组件通信

    ```vue
    <!--Son.vue-->
    <template>
    	<div>
            我是son组件 {{ tilte }}
            <button @click="changeBtn">修改标题</button>
        </div>
    </template>
    
    <script>
        export default {
            // 通过props进行接收，title为定义的形参
            props: ["title"],
            methods: {
                changeBtn() {
                    // 子组件通过$emit向父组件发送触发的事件
                    this.$emit("changeTitle", "修改后的标题")
                }
            }
        }
    </script>
    
    <style>
    </style>
    
    ```

    ```vue
    <!--App.vue-->
    <template>
    	<div>
            我是App组件
            <!--父组件中通过@changeTitle事件去触发change函数，从而修改标题 -->
            <Son :title="myTitle" @changeTitle=change></Son>
        </div>
    </template>
    
    <script>
    	import Son from './components/Son.vue'
        export default {
            data() {
                return {
                    myTitle: "我的标题"
                }
            }，
            components: {
            	Son
        	},
            methods: {
                change(newValue) {
                    this.myTitle = newValue
                }
            }
        }
        
    </script>
    
    <style>
    </style>
    ```
    - props校验
    
        1. props简单类型校验
            ```vue
            <script>
            	props: {
                    num: Number // 假设接收参数名为num，那么校验属性类型为Number
                }
            </script>
            ```
    
        2. props复杂类型校验
            ```vue
            <script>
            	props: {
                    // 假设接收参数名为num
                    num: {
                        type: Number,  // 校验属性是否为Number
                        default: 默认值,  // 若没有传递参数则使用默认值
                        required: true/false, // 是否必须传递参数
                        validator (v) {
                            // 自定义参数校验逻辑
                            // 如果符合校验逻辑则return true
                            // 如果不符合校验逻辑则return false
                        }
                    }
                }
            </script>
            ```
    
            
    
    - props的单向数据流
    
2. 非父子关系：通过<font color=red>**provide & inject**</font>和<font color=red>**eventbus**</font>进行
3. 通用通信方案：通过<font color=red>**vuex**</font>（但是通常用于复杂场景）
