# 前端学习常见问题

## 一、JS篇

### 1.节流

### 2.防抖

### 3.this指向

### 4.改变this指向

### 5.对象实例构造方法

### 6.prototype详解

### 7.闭包

### 8.函数参数

## 二、Vue篇

### 1.vue中常用的指令
  - v-if/v-else
  - v-for
  - v-bind
  - v-model
  - v-slot
  - @

### 2.computed计算属性（简写/完整写法）

- 以下是计算属性的简写写法，无法直接修改计算属性的值

````html
<div id="app">
    姓：<input type="text" v-model="firstName"> +
    名：<input type="text" v-model="lastName"> =
    <span> {{ fullName }} </span>
    
    <button>改名卡</button>
</div>
<script>
	const app = new Vue({
        el: '#app',
        data: {
            firstName: '张',
            lastName: '飞'
        },
        computed: {
            fullName() {
                return this.firstName + this.lastName
            }
        }
    })
</script>
````

- 以下是计算属性的完整写法，可以修改计算属性的值，间接的影响组成计算属性的值

```` html
<div id="app">
    姓：<input type="text" v-model="firstName"> +
    名：<input type="text" v-model="lastName"> =
    <span> {{ fullName }} </span>
    
    <button @click="changeName">改名卡</button>
</div>
<script>
	const app = new Vue({
        el: '#app',
        data: {
            firstName: '张',
            lastName: '飞'
        },
        methods: {
            changeName() {
                this.fullName = '姬小满'
            }
        },
        computed: {
            fullName: {
                get() {
                    return this.firstName + this.lastName
                },
                set(value) {
                    this.firstName = value.slice(0,1)
                    this.lastName = value.slice(1)
                }
            }
        }
    })
</script>
````

### 3.watch监听器（简写/完整写法）

- 以下是监听器的简写写法

````html
<div id="app">
    <textarea v-model="words"></textarea>
    <textarea v-model="obj.words"></textarea>
</div>

<script>
	const app = new Vue({
        el: '#app',
        data: {
            words: '',
            obj: {
            	words: ""
        	}
        },
        watch: {
            words(newValue, oldValue) {
                console.log(`变更前: ${oldValue}, 变更后: ${newValue}`)
            },
            // 对象的写法
            'obj.words'(newValue, oldValue) {
                console.log(`变更前: ${oldValue}, 变更后: ${newValue}`)
            }
        }

    })
</script>
````

- 以下是监听器的完整写法

````html
<div id="app">
    <textarea v-model="obj.lang"></textarea>
    <textarea v-model="obj.words"></textarea>
</div>

<script>
	const app = new Vue({
        el: '#app',
        data: {
            words: '',
            obj: {
            	words: ""
                lang:
        	}
        },
        watch: {
           obj: {
               deep: true,   // obj对象下的所有内容都进入监听状态
               immediate: true,  // 是否立即执行一次handler中的函数
               handler(newValue){
                   console.log(`我是新的值${newValue}`)
               }
           }
        }

    })
</script>
````

### 4.Vue生命周期

① 创建阶段（before Create / created）：一般用户获取响应式数据

② 挂载阶段（before Mount / mounted）：渲染模版模版，到达mounted阶段时，完成dom结构渲染

③ 更新阶段（before Update / updated）：修改数据，更新视图

④ 销毁阶段（before Destroy / destroyed）：销毁实例

### 5.脚手架（Vue-CLi）
- 使用步骤
  
  1. 全局安装：yarn global add @vue-cli 或 npm i @vue/cli -g
  2. 查看Vue版本：vue --version
  3. 创建项目架子：vue create project-name （项目名不能用中文）
  4. 启动项目：yarn serve 或 npm run serve （从package.json得出）


- 创建架子目录结构
    ![架子目录结构](assets%2Fimg.png)

### 6.组件化开发&根组件
![组件化开发&根组件](assets%2Fimg_2.png)
![App.Vue根组件](assets%2Fimg_1.png)


### 7.普通组件的注册使用
- 局部注册：只能在注册的组件内使用
  1. 创建.Vue文件
  2. 通过import引入创建好的组件
  ![注册普通组件](assets%2Fimg_3.png)
  **如果组件名和组件对象名称都是一样可以直接用简写**
  ```vue
  <script>
  import HmHeader from './components/HmHeader'
  
  export default {
    components: {
        HmHeader
    }
  } 
  </script>
  ```
  
- 全局注册：所有组件内都能使用
  1. 创建.Vue文件
  2. main.js中进行全局注册
     ![注册全局组件](assets%2Fimg_4.png)
     **全局注册后，该组件不需要导入可以直接使用**


### 8.组件的样式冲突
默认情况：写在组件中的样式会**全局生效** -> 因此很容易造成多个组件之间的样式冲突问题
1. **<font color=red>全局样式</font>**：默认组件中的样式会作用到全局
2. **<font color=red>局部样式</font>**：可以给组件上<font color=red>scoped</font>属性，让样式只作用于当前组件中


### 9.组件通信
1. 父子关系：通过<font color=red>**props**</font>和<font color=red>**$emit**</font>进行父子组件通信
    - 父组件向子组件通信：父组件通过子组件的props中定义的变量参数，在父组件中使用子组件时，通过v-bind将数据传递给子组件，子组件通过props中定义的变量参数进行接收

    ```vue
    <!--App.vue-->
    <template>
    	<div>
            我是App组件
            <Son :title="myTitle"></Son>
        </div>
    </template>
    
    <script>
    	import Son from './components/Son.vue'
        export default {
            data() {
                return {
                    myTitle: "我的标题"
                }
            }，
            components: {
            	Son
        	}
        }
        
    </script>
    
    <style>
    </style>
    ```

    ```vue
    <!--Son.vue-->
    <template>
    	<div>
            我是son组件 {{ tilte }}
            
        </div>
    </template>
    
    <script>
        export default {
            // 通过props进行接收，title为定义的形参
            props: ["title"]
        }
    </script>
    
    <style>
    </style>
    
    ```

    - 子组件向父组件通信：子组件通过$emit向父组件发送触发的事件，父组件通过对应的事件调用方法，从而达到子组件向父组件通信

    ```vue
    <!--Son.vue-->
    <template>
    	<div>
            我是son组件 {{ tilte }}
            <button @click="changeBtn">修改标题</button>
        </div>
    </template>
    
    <script>
        export default {
            // 通过props进行接收，title为定义的形参
            props: ["title"],
            methods: {
                changeBtn() {
                    // 子组件通过$emit向父组件发送触发的事件
                    this.$emit("changeTitle", "修改后的标题")
                }
            }
        }
    </script>
    
    <style>
    </style>
    
    ```

    ```vue
    <!--App.vue-->
    <template>
    	<div>
            我是App组件
            <!--父组件中通过@changeTitle事件去触发change函数，从而修改标题 -->
            <Son :title="myTitle" @changeTitle=change></Son>
        </div>
    </template>
    
    <script>
    	import Son from './components/Son.vue'
        export default {
            data() {
                return {
                    myTitle: "我的标题"
                }
            }，
            components: {
            	Son
        	},
            methods: {
                change(newValue) {
                    this.myTitle = newValue
                }
            }
        }
        
    </script>
    
    <style>
    </style>
    ```
    - props校验
    
        1. props简单类型校验
            ```vue
            <script>
            	props: {
                    num: Number // 假设接收参数名为num，那么校验属性类型为Number
                }
            </script>
            ```
    
        2. props复杂类型校验
            ```vue
            <script>
            	props: {
                    // 假设接收参数名为num
                    num: {
                        type: Number,  // 校验属性是否为Number
                        default: 默认值,  // 若没有传递参数则使用默认值
                        required: true/false, // 是否必须传递参数
                        validator (v) {
                            // 自定义参数校验逻辑
                            // 如果符合校验逻辑则return true
                            // 如果不符合校验逻辑则return false
                        }
                    }
                }
            </script>
            ```
    
    - props的单向数据流
    
        数据流动的方向是单一的，假设数据源在A组件中，那么除了A组件其他组件（子组件、其他组件）都无法修改A组件中的数据源数据，只有在A组件中可以修改，或者通过组件通信的方式去通知A组件进行修改
    
        
    
2. 非父子关系：通过<font color=red>**provide & inject**</font>和<font color=red>**eventbus**</font>进行
    - 事件总线（eventbus）<font color=red>**(仅适用于vue2)**</font>
        1. 创建一个空的Vue实例作为事件总线
    
        ```js
        // eventbus.js
        
        import Vue from 'vue'
        const eventBus = new Vue()
        export default Bus
        ```
        2. 接收方需要订阅消息

        ```vue
        <script>
            import Bus from 'eventbus'
            export default {
                created() {
                    Bus.$on('订阅的事件名称', msg => {
                        console.log(msg)
                    })
                }
            }
        </script>
        ```
        3. 发送方需要发布消息

        ```vue
        <template>
            <button @click="sendMessage">发送消息</button>
        </template>
        <script>
            import Bus from 'eventbus'
            export default {
                methods: {
                    sendMessage(){
                        Bus.$emit('订阅的事件名称', '发送的消息')
                    }     
                } 
            }
        </script>
        <style>
        </style>
        ```
        4. 需要特别注意的是：事件总线不是仅仅一对一的组件进行通信，而是一对多的情况，只要订阅发布的事件的组件，都可以接收到此消息

    - provide & inject
    
      主要用于祖先组件与其深层后代组件之间的数据通信
        - 祖先组件中provide提供数据
        ```vue
        <script>
            export default {
                data() {
                    return {
                        color: 'red',
                        userInfo: {
                            name: 'xxxx',
                            age: 23
                        }
                    }
                },
                provide() {
                    return {
                        color: this.color,   // 普通类型【非响应式】
                        userInfo: this.userInfo  // 复杂类型【响应式】
                    }
                }
            }
        </script>
        ```
        - 子孙组件中可以直接通过inject取得父组件提供的数据
        ```vue
      <script>
      	export default {
              inject: ['color', 'userInfo'],
              created() {
                  console.log(this.color, this.userInfo)
              }
          }
      </script>
        ```
      
      
    
3. 通用通信方案：通过<font color=red>**vuex**</font>（但是通常用于复杂场景）


### 10.v-model原理
v-model本质上就是语法糖，实际上就是绑定表单属性和表单事件的合写，例如input元素，就是value属性和input事件的合写，对于checkbox，则是check属性和change事件的合写
```vue
<template>
    <div>
        <input v-model="msg1" type="text"/>
        <!--输入框通过v-bind实现value和msg2进行双向数据绑定，模版中通过input事件获取最新的数据值-->
        <!--注意：模版中$event相当于js中的事件对象e-->
        <input :value="msg2" @input="msg2 = $event.target.value" type="text">
        <input type="checkbox" v-model="isChecked1">
        <input type="checkbox" :checked="isChecked2" @change="$event.target.value">
        
    </div>
</template>
<script>
    export default {
        data() {
            return {
                msg1: '',
                msg2: '',
                isChecked1: false,
                isChecked2: false
            }
        }
    }
</script>
<style>
</style>
```